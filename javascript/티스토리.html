<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body>
    console을 쓰는이유
1. dom, defer, async
2. var let const 차이
(var 호이스팅가능)변수와 상수
해커들이 코드를 변경하는 걸 방지한다 const
-security
-thread safety 갑을 동시변경 위험
-reduce human mistake 코드 변경시 실수 방지한다
3. variable types
number
string
boolean
null 너는 텅빈값이야
undefined 선언은 됐지만 할당x
symbol
4. 연산자
함수호출시 제일 뒤로
ex(or: value1 || valaue2 || function)
5.function
반복되는 일
이것은 함수입니다(function) 함수이름(코드와 관련있는) {함수의 내용}


함수는 값을 받아 이 함수 안에서  매개변수를 이용한 식(오브젝트든 머든)을 만들어 리턴값으로 출력해준다.

함수 선언
function이라는 키워드와 원하는 함수이름을 정의하고 ()안에는 어떤값을 전달받아 올건지(전달받는 인자를 정의)
{}안에는 실제로 함수 안에서 어떤 코드가 동작하는지
함수도 오브젝트랑 똑같다 함수이름은 함수자체를 저장하지 않고 함수가 정의된 곳의 주소를 저장한다(reference)
어떤 변수에 함수를 할당하면 함수를 가르키는 주소가 할당이 된다. 결국 변수와 함수는 같다
함수의 인자(매개변수)를 적을 때는 함수의 내용과 관련된 의미있는 이름을 지어준다

함수 이것은 함수입니다.
함수이름 가능한 의미 있는 이름(어떤 기능인지)
()안에 들어가는 인자들이 값을 받아옴(기능을 이루는 각각의 것과 관련된)-변수와 마찬가지로 인자 하나당 메모리공간이
하나씩 생긴다(함수를 만든시점에는 메모리가 비어있다.)
코드블록 = 기능



function(a,b) {
    const sum = a+b;
}

함수 호출
함수이름();

함수 타입
어떤 기능을 수행
또는 어떤 값을 받아와 어떤 변수에 접근해 
계산을 한다음 특정한 값을 전달


api?
조건이 아닐때 빨리 리턴해서 함수 종료하고 맞을때만 필요한 로직을 실행
해야 가독성도 좋고 그렇다
익명함수란 함수의 이름이 없는거
콜백함수
function func(answer, printyes, printno)
매개변수인 answer에 대답이 맞으면ㅡ 프린트예스 함수 출력 아니면 no



6.클래스와 오브젝트
클래스는 틀(오브젝트를 이루는 속성, 메서드, 등을 모아놓음) 오브젝트는 틀을이용해서 만들어진거
7.오브젝트
obg.key와obg[key]
8.배열
비슷한 종료에 데이터를 모아놓는 것 = 자료구조 


9.변수
숫자면 num age 등등의 관련 이름으로 변수이름 짓기 어떤 정보를 갖고있는지 유추하기 쉽다
변수를 선언하면 그 변수만의 메모리 공간이 생긴다. 
가장작은 데이터 타입(primitive 타입) = 숫자 스트링 불린 null undefined symbol 
// 이런 데이터 타입을 제외한 모두가 object(최소한 한두가지의 다양한 데이터를 한군데에다 묶어 놓은 아이)(배열, 리스트 함수..)
let obg - {}; obg라는 변수에는 123이 들어가있다 오브젝트는 너무커 변수에 들어가기엔 너무 크다 오브젝트는 각각 키마다 
공간이 할당이 된다. 그것들을 묶은 주소(reference)가 있는데 그 주소만 obg라는 변수에 할당이된다.
상수변수(const)를 쓰는 obg는 obg 자체가 담겨있는게 아니라 obg를 가리키는 reference가 담겨있기 때문에 reference는
다른 obg로 변경 불가능하지만reference가 가리키는 obg의 안의 내용은 변경이 가능하다.










<h3>window 객체</h3>
<p>1. 브라우저 안의 모든 요소들이 소속된 객체로, 최상위에 있기 때문에 어디서든 접근이 가능하다고 해서 
    '전역 객체'라고도 부른다.<br> 2. 일반적으로 우리가 열고 있는 브라우저의 창(browser window)을 의미하고, 
    창 열기, 창 닫기, 창 크기 조절 등 창을 제어하는 다양한 작업을 할 수 있다.
</p>


<h3>브라우저 객체 모델BOM (Browser Object Model)</h3>
    <p>브라우저 객체 모델이란, 말 그대로 브라우저에 대한 모든 내용을 담고있는 객체이다.
        브라우저에 관한 정보를 제공하거나 브라우저의 모양을 제어하도록 제공되는 객체들이다.   
        대표적으로 아래와 같은 객체들이 존재한다.</p>

        <h4>window 객체</h4>
        <p> 인터넷 브라우저를 보면 위에 탭들도 있고, 주소창도 있고, 즐겨찾기 그리고 툴바들도 있을 수 있고요. 그 다음부터는 이제 웹사이트가 표시됩니다. 여기서 브라우저 전체를 담당하는 게 Window 객체이고, 웹사이트만 담당하는게 Document 객체라고 이해하시면 됩니다. Document도 Window 객체 안에 들어있습니다.
            window는 모든 객체의 조상입니다. 전역객체(글로벌객체)라고 하는데요. 모든 객체를 다 포함하고 있기 때문에 window는 그냥 생략가능합니다.</p>
        
        <h4>location 객체</h4>
        <p>현재 웹 브라우저가 보고 있는 위치(페이지)에 관한 객체  location.reload()로 새로고침도 가능합니다.
             location.replace()는 현재 주소를 다른 주소로 교체합니다. (다른 페이지로 이동하지만 이전 페이지 기록이 남지 않습니다)
        </p>

        <h4>navigator 객체</h4>
        <p>navigator 객체는 브라우저 공급자 및 버전 정보 등을 포함한 브라우저에 대한 다양한 정보를 저장하는 객체입니다.</p>

        <h4>Screen 객체</h4>
        <p>screen 객체는 사용자의 디스플레이 화면에 대한 다양한 정보를 저장하는 객체입니다.
            너비(width), 높이(height), 픽셀(pixelDepth), 컬러(colorDepth), 화면 방향(orientation)
            , 작업표시줄을 제외한 너비와 높이(availWidth, availHeight) 등이 있습니다.</p>

        <h4>history 객체</h4>
        <p>웹 브라우저의 페이지 이동 내역을 담고 있는 객체
            히스토리간에 이동(history.go(페이지수))할 수도 있습니다. history.length는 뒤로가기할 수 있는 페이지의 개수를 의미합니다.
        </p>



  
</body>
  
<h3>position 속성</h3>
<p>CSS에서 position 속성은 HTML 문서 상에서 요소가 배치되는 방식을 결정합니다. 많은 경우, position 속성은 요소의 정확한 위치 지정을 위해서 top, left, bottom, right 속성과 함께 사용됩니다.</p>

<h4>position: static</h4>
<p>position 속성을 별도로 지정해주지 않으면 기본값인 static이 적용됩니다. position 속성이 static인 요소는 HTML 문서 상에서 원래 있어야하는 위치에 배치됩니다.
     이 말은 요소들이 HTML에 작성된 순서 그대로 브라우저 화면에 표시가 된다는 것을 뜻하며, 따라서 top, left, bottom, right 속성값은 position 속성이 static일 때는 무시됩니다.</p>
<h4>position: relative</h4>
<p>position 속성을 relative로 설정하게 되면, 요소를 원래 위치에서 벗어나게 배치할 수 있게 됩니다. 요소를 원래 위치를 기준으로 상대적(relative)으로 배치해준다고 생각하시면 이해가 쉬울 것 같은데요. 요소의 위치 지정은 top, bottom, left, right 속성을 이용해서, 요소가 원래 위치에 있을 때의 상하좌우로 부터 얼마나 떨어지게 할지를 지정할 수 있습니다.</p>
<h4>position: absolute</h4>
<p>배치 기준을 자신이 아닌 상위 요소에서 찾습니다. DOM 트리를 따라 올라가다가 position 속성이 static이 아닌 첫 번째 상위 요소가 해당 요소의 배치 기준으로 설정되는데요. 만약에 해당 요소 상위에 position 속성이 static이 아닌 요소가 없다면, DOM 트리에 최상위에 있는 &lt;body&gt; 요소가 배치 기준이 됩니다.  대부분의 경우, 부모 요소(가장 가까운 상위 요소)를
     기준으로 top, left, bottom, right 속성을 적용해야하기 때문입니다. 따라서 어떤 요소의 display 속성을 absolute로 설정하면, 부모 요소의 display 속성을 relative로 지정해주는 것이 관례입니다. 또한 position: absolute인 요소는 HTML 문서 상에서 독립되어 앞뒤에 나온 요소와 더 이상 상호작용을 하지 않게 된다는 것입니다. 
    그렇기 때문에 원래있던 자리는 빈자리가 되는 것입니다.</p>
<h4>position: fixed</h4>
<p>화면을 위아래로 스크롤하더라도 브라우저 화면의 특정 부분에 고정되어 움직이지 않는 UI를 본적이 있으신가요? 보통 라이브 채팅 버튼을 구현할 때 많이 쓰이는 기법인데요. position 속성을 fixed로 지정하면 이렇게 요소를 항상 고정된(fixed) 위치에 배치할 수 있습니다.

    이게 가능한 이유는 fixed 속성값의 배치 기준이 자신이나 부모 요소가 아닌 뷰포트(viewport), 즉 브라우저 전체화면이기 때문인데요. top, left, bottom, right 속성은 각각 브라우저 상단, 좌측, 하단, 우측으로 부터 해당 요소가 얼마나 떨어져있는지를 결정합니다.</p>
<h4></h4>
<p></p>
<h4></h4>
<p></p>

<h3>이미지 스프라이트의 정의</h3>
<p>여러 개의 이미지를 하나의 이미지로 만들어 놓은 것을 의미합니다.</p>

<h3>특징</h3>

<h4>1. 요청을 단 한번 만한다.</h4>
<p> 브라우저는 화면을 그릴 때 필요한 모든 자원(이미지, CSS, JS 등)을 서버에 요청하고 가져와 사용합니다. 서버에 요청하고 가져오는 작업은 일괄적으로 한 번에 이루어지지 않습니다. 서버에 자원을 요청하는 구문이 사용된 횟수만큼 서버에 자원을 요청합니다.
    예를 들어 위와 같은 예제는 서버에서 이미지를 가져오기 위해 서버에 3번의 요청을 합니다. 즉 자원을 사용하는 구문 하나는 서버 요청 하나입니다. 예제 코드는 3번의 이미지 요청을 이야기했지만, 가져와야 하는 이미지가 10개 혹은 그 이상이 되면 서버에 이미지를 요청하기 위해서 많은 브라우저 자원을 사용해야 합니다. 이는 결국 화면을 그리는 속도를 저해합니다.
    그렇기 때문에 하나의 이미지에 여러 개의 이미지를 합쳐서 사용하는 이미지 스프라이트를 사용하면, 서버에 이미지를 요청하는 횟수를 한 번으로 줄 일수 있습니다. 거기에 CSS를 사용하면 이미지 스프라이트(여러 개의 이미지가 하나로 합쳐진 이미지)를 하나의 이미지처럼 보이게 할 수 있습니다. 즉 이미지 스프라이트를 잘 활용한다면, 서버에 이미지 요청하는 횟수를 줄이고 화면을 빠르게 그릴 수 있습니다.
</p>

<h4>2. 하나의 이미지 파일만 관리한다.</h4>
<p> 이미지 스프라이트는 여러 개의 이미지를 하나로 합쳤기 때문에, 합친 이미지의 개수만큼 관리를 해야 하는 이미지 파일이 줄어듭니다. 관리해야 하는 이미지 수가 줄어든다는 것은 관리하는 대상이 줄어든다는 말과 같기 때문에 유지보수 측면에서도 유리한 점이 있습니다.
    다만 스프라이트 이미지를 만드는 경우는 아이콘들처럼 문맥적으로 같은 유형을 묶어서 사용하는 것이 좋습니다. 아무리 하나의 이미지라도 다른 의미를 지닌 이미지를 합친다면, 하나의 이미지를 관리하는 게 아니라 여러 개의 이미지를 하나의 파일에서 관리하는 것 일 뿐입니다.
   </p>

<h4>1. 이미지 스프라이트로 만드는 아이콘</h4>
<p></p>
<h4>2. 역동적인 이미지 스프라이트 사용법</h4>
<p></p>
   
<h3>ir기법(Image Replacement)</h3>
<p>- IR 기법은 이미지의 대체텍스트를 제공하기 위한 CSS 기법으로 아래와 같이 다양한 CSS 기법을 사용하여 이미지의 대체 텍스트를 제공할 수 있습니다. </p>

<h3>IR 기법(Image Replacement)의 종류</h3>
<h4>Phark Method</h4>
<p>- 의미있는 이미지의 대체 텍스트를 제공하는 경우에 사용합니다.
    - 이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 text-indent를 이용하여 화면 바깥으로 (-9999px만큼 내어 쓰기) 빼내어 보이지 않게 하는 방법입니다. </p>
<h4>WA IR</h4>
<p>- 의미있는 이미지의 대체 텍스트로 이미지가 없어도 대체 텍스트를 보여주고자 할 때 사용합니다.
    - 이미지로 대체 할 엘리먼트에 배경이미지를 설정하고 글자는 span 태그로 감싼 후 z-index:-1을 이용하여 화면에 보이지 않게 처리합니다.</p>
<h4>Screen out</h4>
<p>대체 텍스트가 아닌 접근성을 위한 숨김 텍스트를 제공할 때 사용합니다.</p>
https://xxoyeong.tistory.com/81
https://velog.io/@71summernight/Semantic-Web-Semantic-Tag-aidm2h5f
https://designer-ej.tistory.com/entry/CSS-background-%EC%86%8D%EC%84%B1-%EC%A0%95%EB%A6%ACcolor-image-position-repeat-%EB%93%B1
https://sohyunsaurus.tistory.com/57


<h3>콜백함수란?</h3>
<p>콜백함수는 간단하게 다른 함수에 매개변수로 넘겨준 함수를 말한다. 매개변수로 넘겨받은 함수는 일단 넘겨받고, 때가 되면 나중에 호출(called back)한다는 것이 콜백함수의 개념이다.</p>

<p>예를 들자면 이런 것이다.
    코드를 살펴보면 checkGang, linkGang, goodGang 총 3가지 함수를 선언하고checkGang 함수를 호출할 때 매개변수로 count에 숫자값을,그리고 link와 good에 각각 linkGang과 goodGang함수를 전달했다.여기서 linkGang함수와 goodGang함수가 콜백함수 인 것이다.
     checkGang함수가 먼저 호출되고, 매개변수로 들어온 count의 값에 따라 linkGang과 goodGang함수 둘 중 한 가지가 나중에 호출된다.</p>
<p>위 코드는 count가 2이기 때문에 linkGang이 실행된다.</p>

<h3>콜백함수가 필요한 이유</h3>
<p>간단하게 말하면 여러 함수들을 선언하고, 어느 한 함수가 실행될 때,
    상황에 따라 필요한 다른 함수를 실행하고 싶을 때 활용할 수 있다.</p><br>
<p>콜백함수는 때로는 그냥 가독성이나 코드 재사용성 면에서도 활용한다.</p>   

<h3>메서드(method)란?</h3>
<p>어떤 객체가 가지고 있는 어떤 동작을 말한다. 일반적으로 자바스크립트에서는 일반적으로 객체 안에 프로퍼티로 정의된 함수를 메서드라고 부른다.</p>